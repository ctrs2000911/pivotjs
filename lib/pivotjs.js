// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var Aggregator, Composer, Pivot, _, root,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = (typeof window !== "undefined" && window !== null ? window._ : void 0) ? window._ : require('lodash');

  Pivot = (function() {
    var average, count, counta, max, median, min, mode, sum, unique;

    function Pivot(param) {
      this.param = param;
      this.processRecord = bind(this.processRecord, this);
      this.formats = {
        int: ',f',
        float: ',.2f',
        abbreviation: '2s',
        percent: '.2%'
      };
      this.defaultFormat = 'int';
      this.defaultFormatExpression = this.formats[this.defaultFormat];
      this.formatFunction = function(val, format) {
        return val;
      };
      this.aggregatorEvaluateFunction = function(expression) {
        return null;
      };
      this.records = this.param.records || [];
      this.rowAttrs = this.param.rows || [];
      this.colAttrs = this.param.cols || [];
      this.measureAttrs = this.param.measures || [];
      _.each(this.measureAttrs, (function(_this) {
        return function(measure) {
          if (_.has(measure, 'format')) {
            return measure.formatExpression = measure.format === 'custom' ? measure.formatExpression : _.has(_this.formats, measure.format) ? _this.formats[measure.format] : _this.defaultFormatExpression;
          } else {
            measure.format = _this.defaultFormat;
            return measure.formatExpression = _this.defaultFormatExpression;
          }
        };
      })(this));
      this.rowKeys = [];
      this.colKeys = [];
      this.measureKeys = [];
      this.serializedRowKeys = [];
      this.serializedColKeys = [];
      this.sortedRowKeys = null;
      this.sortedColKeys = null;
      this.map = {};
      this.grandTotal = new Composer(this, [], []);
      this.rowTotals = {};
      this.colTotals = {};
      this.aggregationFunctions = {
        sum: sum,
        count: count,
        counta: counta,
        unique: unique,
        average: average,
        median: median,
        mode: mode,
        max: max,
        min: min
      };
    }

    Pivot.prototype.getNestedKeys = function(dataset) {
      var _dataset, _path, childrenToArray, i, j, len, len1, next, node, path, root;
      if (dataset.length === 0 || !dataset) {
        return {
          children: []
        };
      }
      root = {};
      node = null;
      next = null;
      _dataset = _.map(dataset, function(arr) {
        var _arr;
        _arr = JSON.parse(JSON.stringify(arr));
        _arr.unshift('root');
        return _arr;
      });
      for (i = 0, len = _dataset.length; i < len; i++) {
        path = _dataset[i];
        node = root;
        for (j = 0, len1 = path.length; j < len1; j++) {
          _path = path[j];
          node.children || (node.children = {});
          next = node.children[_path];
          next || (next = node.children[_path] = {
            key: _path
          });
          node = next;
        }
      }
      root = _.values(root.children)[0];
      childrenToArray = function(n, depth) {
        if (depth == null) {
          depth = 0;
        }
        _.extend(n, {
          depth: depth
        });
        if (n.children) {
          _.extend(n, {
            children: _.values(n.children)
          });
          return _.each(n.children, function(child) {
            return childrenToArray(child, n.depth + 1);
          });
        }
      };
      childrenToArray(root);
      return root;
    };

    Pivot.prototype.getRowKeys = function() {
      return this.rowKeys;
    };

    Pivot.prototype.getRowAttrs = function() {
      return this.rowAttrs;
    };

    Pivot.prototype.getSortedRowKeys = function() {
      return this.sortedRowKeys || (this.sortedRowKeys = this.getSortedKeys(this.rowKeys, this.rowAttrs, 'row'));
    };

    Pivot.prototype.getNestedRowKeys = function() {
      return this.getNestedKeys(this.getSortedRowKeys());
    };

    Pivot.prototype.getColKeys = function() {
      return this.colKeys;
    };

    Pivot.prototype.getColAttrs = function() {
      return this.colAttrs;
    };

    Pivot.prototype.getSortedColKeys = function() {
      return this.sortedColKeys || (this.sortedColKeys = this.getSortedKeys(this.colKeys, this.colAttrs, 'col'));
    };

    Pivot.prototype.getNestedColKeys = function() {
      return this.getNestedKeys(this.getSortedColKeys());
    };

    Pivot.prototype.getMeasureAttrs = function() {
      return this.measureAttrs;
    };

    Pivot.prototype.getSortedKeys = function(keys, attrs, sortKind) {
      var sort;
      if (keys == null) {
        keys = [];
      }
      if (attrs == null) {
        attrs = [];
      }
      if (sortKind == null) {
        sortKind = null;
      }
      sort = function(as, bs) {
        var a, a1, b, b1, rd, rx, rz;
        rx = /(\d+)|(\D+)/g;
        rd = /\d/;
        rz = /^0/;
        if (typeof as === "number" || typeof bs === "number") {
          if (isNaN(as)) {
            return 1;
          }
          if (isNaN(bs)) {
            return -1;
          }
          return as - bs;
        }
        a = String(as).toLowerCase();
        b = String(bs).toLowerCase();
        if (a === b) {
          return 0;
        }
        if (!(rd.test(a) && rd.test(b))) {
          return (a > b ? 1 : -1);
        }
        a = a.match(rx);
        b = b.match(rx);
        while (a.length && b.length) {
          a1 = a.shift();
          b1 = b.shift();
          if (a1 !== b1) {
            if (rd.test(a1) && rd.test(b1)) {
              return a1.replace(rz, ".0") - b1.replace(rz, ".0");
            } else {
              return (a1 > b1 ? 1 : -1);
            }
          }
        }
        return a.length - b.length;
      };
      return _.map(keys, function(key) {
        return _.extend([], key);
      }).sort((function(_this) {
        return function(a, b) {
          var _key, _value_a, _value_b, args_a, args_b, ascending, b_value, diff, i, index_a, key_a, key_b, len, pos, ref, sortObject, type, value_a;
          diff = 0;
          if (a.length !== b.length) {
            return diff;
          }
          for (index_a = i = 0, len = a.length; i < len; index_a = ++i) {
            value_a = a[index_a];
            sortObject = (ref = attrs[index_a]) != null ? ref.sort : void 0;
            type = (sortObject != null ? sortObject.type : void 0) || null;
            ascending = sortObject.ascending === true ? 1 : -1;
            diff = (function() {
              var ref1, ref2, ref3, ref4, ref5;
              switch (type) {
                case 'self':
                  b_value = b[index_a];
                  return sort(value_a, b_value) * ascending;
                case 'measure':
                  key_a = _.slice(a, 0, index_a + 1);
                  key_b = _.slice(b, 0, index_a + 1);
                  _key = sortObject.key;
                  pos = sortObject.measureIndex || 0;
                  ref1 = sortKind === 'row' ? [[key_a, _key], [key_b, _key]] : [[_key, key_a], [_key, key_b]], args_a = ref1[0], args_b = ref1[1];
                  _value_a = ((ref2 = this.values.apply(this, args_a)) != null ? (ref3 = ref2[pos]) != null ? ref3.value : void 0 : void 0) || null;
                  _value_b = ((ref4 = this.values.apply(this, args_b)) != null ? (ref5 = ref4[pos]) != null ? ref5.value : void 0 : void 0) || null;
                  return sort(_value_a, _value_b) * ascending;
                default:
                  return 0;
              }
            }).call(_this);
            if (diff !== 0) {
              break;
            }
          }
          return diff;
        };
      })(this));
    };

    Pivot.prototype.serializeKey = function(keys) {
      return JSON.stringify(keys);
    };

    Pivot.prototype.deserializeKey = function(sKey) {
      return JSON.parse(sKey);
    };

    Pivot.prototype.setFormatFunction = function(func) {
      return this.formatFunction = func;
    };

    Pivot.prototype.setAggregatorEvaluateFunction = function(func) {
      return this.aggregatorEvaluateFunction = func;
    };

    Pivot.prototype.populate = function() {
      return _.each(this.records, (function(_this) {
        return function(record) {
          return _this.processRecord(record);
        };
      })(this));
    };

    Pivot.prototype.processRecord = function(record) {
      var c, cKey, cKeys, ckey, colKeyList, colKeys, i, index, j, k, key, l, len, len1, len2, len3, len4, len5, m, measure, o, r, ref, ref1, ref2, ref3, ref4, rkey, rowKeys, serializedColKey, serializedColKeysList, serializedRowKey, serializedRowKeyList, serializedSlicedColKeys, serializedSlicedRowKeys, slicedColKeys, slicedRowKeys;
      rowKeys = (function() {
        var i, len, ref, results;
        ref = this.rowAttrs;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          r = ref[i];
          results.push(record[r.id]);
        }
        return results;
      }).call(this);
      colKeys = (function() {
        var i, len, ref, results;
        ref = this.colAttrs;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          c = ref[i];
          results.push(record[c.id]);
        }
        return results;
      }).call(this);
      serializedRowKey = this.serializeKey(rowKeys);
      serializedColKey = this.serializeKey(colKeys);
      serializedColKeysList = [];
      for (index = i = 0, len = colKeys.length; i < len; index = ++i) {
        key = colKeys[index];
        slicedColKeys = colKeys.slice(0, +index + 1 || 9e9);
        serializedSlicedColKeys = this.serializeKey(slicedColKeys);
        serializedColKeysList.push(serializedSlicedColKeys);
        if (indexOf.call(this.serializedColKeys, serializedColKey) < 0) {
          this.colKeys.push(colKeys);
          this.serializedColKeys.push(serializedColKey);
        }
        if (!this.colTotals[serializedSlicedColKeys]) {
          this.colTotals[serializedSlicedColKeys] = new Composer(this, [], slicedColKeys);
        }
      }
      serializedRowKeyList = [];
      for (index = j = 0, len1 = rowKeys.length; j < len1; index = ++j) {
        key = rowKeys[index];
        slicedRowKeys = rowKeys.slice(0, +index + 1 || 9e9);
        serializedSlicedRowKeys = this.serializeKey(slicedRowKeys);
        serializedRowKeyList.push(serializedSlicedRowKeys);
        if (indexOf.call(this.serializedRowKeys, serializedRowKey) < 0) {
          this.rowKeys.push(rowKeys);
          this.serializedRowKeys.push(serializedRowKey);
        }
        if (!this.rowTotals[serializedSlicedRowKeys]) {
          this.rowTotals[serializedSlicedRowKeys] = new Composer(this, slicedRowKeys, []);
        }
        if (colKeys.length !== 0) {
          if (!(serializedSlicedRowKeys in this.map)) {
            this.map[serializedSlicedRowKeys] = {};
          }
          for (k = 0, len2 = serializedColKeysList.length; k < len2; k++) {
            cKey = serializedColKeysList[k];
            if (!(cKey in this.map[serializedSlicedRowKeys])) {
              cKeys = this.deserializeKey(cKey);
              this.map[serializedSlicedRowKeys][cKey] = new Composer(this, slicedRowKeys, cKeys);
            }
          }
        }
      }
      ref = this.measureAttrs;
      for (l = 0, len3 = ref.length; l < len3; l++) {
        measure = ref[l];
        this.grandTotal.add(measure, record);
        colKeyList = serializedColKeysList.length > 0 ? serializedColKeysList : [serializedColKey];
        for (m = 0, len4 = colKeyList.length; m < len4; m++) {
          ckey = colKeyList[m];
          if ((ref1 = this.colTotals[ckey]) != null) {
            ref1.add(measure, record);
          }
          for (o = 0, len5 = serializedRowKeyList.length; o < len5; o++) {
            rkey = serializedRowKeyList[o];
            if ((ref2 = this.rowTotals[rkey]) != null) {
              ref2.add(measure, record);
            }
            if ((ref3 = this.map[rkey]) != null) {
              if ((ref4 = ref3[ckey]) != null) {
                ref4.add(measure, record);
              }
            }
          }
        }
      }
    };

    Pivot.prototype.values = function(rowKey, colKey) {
      var ref, ref1, ref2, ref3, sKey;
      if (rowKey.length !== 0 && colKey.length !== 0) {
        return ((ref = this.getComposer(rowKey, colKey)) != null ? ref.values() : void 0) || null;
      } else if (rowKey.length === 0 && colKey.length === 0) {
        return ((ref1 = this.grandTotal) != null ? ref1.values() : void 0) || null;
      } else if (colKey.length === 0) {
        sKey = this.serializeKey(rowKey);
        return ((ref2 = this.rowTotals[sKey]) != null ? ref2.values() : void 0) || null;
      } else if (rowKey.length === 0) {
        sKey = this.serializeKey(colKey);
        return ((ref3 = this.colTotals[sKey]) != null ? ref3.values() : void 0) || null;
      }
    };

    Pivot.prototype.getComposer = function(rowKey, colKey) {
      var serializedColKey, serializedRowKey;
      serializedRowKey = this.serializeKey(rowKey);
      serializedColKey = this.serializeKey(colKey);
      return this.map[serializedRowKey][serializedColKey];
    };

    Pivot.prototype.getComposerWithGap = function(rowKey, colKey, gapIndex) {
      var _colIndex, _colKey, i, index, len, ref, serializedColKey, serializedRowKey;
      if (gapIndex == null) {
        gapIndex = 0;
      }
      index = -1;
      ref = this.getSortedColKeys();
      for (_colIndex = i = 0, len = ref.length; i < len; _colIndex = ++i) {
        _colKey = ref[_colIndex];
        if (!(_.isEqual(_colKey, colKey))) {
          continue;
        }
        index = _colIndex;
        break;
      }
      if (index + gapIndex < 0) {
        return null;
      }
      index += gapIndex;
      serializedRowKey = this.serializeKey(rowKey);
      serializedColKey = this.serializeKey(this.getSortedColKeys()[index]);
      if (this.map[serializedRowKey]) {
        return this.map[serializedRowKey][serializedColKey] || null;
      } else {
        return this.colTotals[serializedColKey] || null;
      }
    };

    sum = function(measureKey, aggregator) {
      return _.reduce(aggregator.records, function(summed, record) {
        return summed + (parseFloat(record[measureKey]) || 0);
      }, 0);
    };

    count = function(measureKey, aggregator) {
      return aggregator.records.length || 0;
    };

    counta = function(measureKey, aggregator) {
      var cnt, i, len, record, ref, ref1;
      cnt = 0;
      ref = aggregator.records;
      for (i = 0, len = ref.length; i < len; i++) {
        record = ref[i];
        if ((ref1 = record[measureKey]) !== null && ref1 !== (void 0)) {
          cnt++;
        }
      }
      return cnt;
    };

    unique = function(measureKey, aggregator) {
      var uniq;
      uniq = _.uniqBy(aggregator.records, function(record) {
        return record[measureKey];
      });
      return uniq.length;
    };

    average = function(measureKey, aggregator) {
      return (sum(measureKey, aggregator) / aggregator.records.length) || null;
    };

    max = function(measureKey, aggregator) {
      var record;
      record = _.maxBy(aggregator.records, function(record) {
        return parseFloat(record[measureKey]) || 0;
      });
      return record[measureKey] || null;
    };

    min = function(measureKey, aggregator) {
      var record;
      record = _.minBy(aggregator.records, function(record) {
        return parseFloat(record[measureKey]) || 0;
      });
      return record[measureKey] || null;
    };

    median = function(measureKey, aggregator) {
      var half, records, val;
      records = _(aggregator.records).chain().map(function(record) {
        var val;
        val = parseFloat(record[measureKey]);
        return val = val.isNaN ? null : val;
      }).compact().value().sort(function(a, b) {
        return a - b;
      });
      half = Math.floor(records.length / 2);
      if (records.length % 2) {
        val = records[half];
      } else {
        val = (records[half - 1] + records[half]) / 2;
      }
      return val || null;
    };

    mode = function(measureKey, aggregator) {
      var counter, i, len, modes, record, records, val;
      counter = {};
      modes = [];
      max = 0;
      records = aggregator.records;
      for (i = 0, len = records.length; i < len; i++) {
        record = records[i];
        val = record[measureKey];
        if (!(val in counter)) {
          counter[val] = 0;
        }
        counter[val]++;
        if (counter[val] === max) {
          modes.push(val);
        } else if (counter[val] > max) {
          max = counter[val];
          modes = [val];
        }
      }
      return modes;
    };

    return Pivot;

  })();

  Composer = (function() {
    function Composer(pivot, rowKey, colKey) {
      this.pivot = pivot;
      this.rowKey = rowKey;
      this.colKey = colKey;
      this.measureKeys = [];
      this.aggregators = [];
    }

    Composer.prototype.values = function() {
      return _.map(this.aggregators, (function(_this) {
        return function(agg) {
          var measure, ref, ref1;
          measure = _this.pivot.deserializeKey(agg.measure);
          return {
            measure: (ref = measure.key) != null ? ref : '-',
            aggregation: measure.aggregation,
            expression: measure.expression,
            format: measure.format,
            formatExpression: measure.formatExpression,
            value: ((ref1 = agg.aggregator) != null ? ref1.value() : void 0) || null
          };
        };
      })(this));
    };

    Composer.prototype.value = function(key, aggregation, pos) {
      var agg, aggs, ref, ref1;
      if (pos == null) {
        pos = 0;
      }
      aggs = pos === 0 || pos === null ? this.aggregators : ((ref = this.pivot.getComposerWithGap(this.rowKey, this.colKey, pos)) != null ? ref.aggregators : void 0) || null;
      aggs = aggs || [];
      agg = _.find(aggs, (function(_this) {
        return function(agg) {
          var measure;
          measure = _this.pivot.deserializeKey(agg.measure);
          return measure.key === key && measure.aggregation === aggregation;
        };
      })(this));
      return (agg != null ? (ref1 = agg.aggregator) != null ? ref1.value() : void 0 : void 0) || null;
    };

    Composer.prototype.add = function(measure, record) {
      var agg, measureKey;
      measureKey = this.pivot.serializeKey(measure);
      if ((_.indexOf(this.measureKeys, measureKey)) < 0) {
        this.measureKeys.push(measureKey);
        this.aggregators.push({
          measure: measureKey,
          aggregator: new Aggregator(this, measure)
        });
      }
      agg = _.find(this.aggregators, function(value) {
        return value.measure === measureKey;
      });
      return agg.aggregator.push(record);
    };

    return Composer;

  })();

  Aggregator = (function() {
    function Aggregator(composer, measure) {
      this.val = null;
      this.measure = measure;
      this.composer = composer;
      this.records = [];
      this.hasCache = false;
    }

    Aggregator.prototype.clearCache = function() {
      this.hasCache = false;
      return this.val = null;
    };

    Aggregator.prototype.push = function(record) {
      this.hasCache = false;
      return this.records.push(record);
    };

    Aggregator.prototype.value = function() {
      var aggregatorFunction, e, error;
      if (this.hasCache) {
        return this.val;
      }
      this.hasCache = true;
      if (this.measure.aggregation) {
        aggregatorFunction = this.composer.pivot.aggregationFunctions[this.measure.aggregation];
        return this.val = aggregatorFunction(this.measure.key, this);
      } else if (this.measure.expression) {
        try {
          return this.val = this.composer.pivot.aggregatorEvaluateFunction.apply(this, [this.measure.expression]);
        } catch (error) {
          e = error;
          return this.val = null;
        }
      } else {
        return this.val = null;
      }
    };

    Aggregator.prototype.formattedValue = function() {
      var _val;
      _val = this.hasCache && this.val !== null ? this.val : this.hasCache === false ? this.value() : null;
      if (_val === null) {
        return null;
      }
      return this.composer.pivot.formatFunction(_val, this.measure.formatExpression || this.composer.pivot.defaultFormatExpression);
    };

    return Aggregator;

  })();

  root = typeof exports !== "undefined" && exports !== null ? exports : window;

  root.Pivot = Pivot;

  root.Composer = Composer;

  root.Aggregator = Aggregator;

}).call(this);
